#!/bin/sh
set -feu

export SUDO_COMMAND="$*" SUDO_USER SUDO_UID SUDO_GID
SUDO_UID=${EUID:-$(id -u)}
if [ "$SUDO_UID" = 0 ]; then
	SUDO_USER=root
else
	SUDO_USER=${USER:-$(id -un)} # NOTE: name in not changed ater su
fi
SUDO_GID=${GROUPS:-$(id -g)}

err() {
	printf '%s\n' "${0##*/}: $1" >&2
	[ "${2:-1}" != 0 ] && exit "${2:-1}"
}

nonempty() {
	[ "$1" != '' ] || err "empty value for $2 not allowed"
}

# safe check if var is NOT exported
vars() {
	for _sudo_tmp; do
		        # (set -u) is needed!
		eval "if ( : \"\${${_sudo_tmp}}\"; ); then err \"err: '$_sudo_tmp' should not be in the enviroment\"; return 1 ; else ${_sudo_tmp}=''; fi "
	done 2>/dev/null 2>/dev/null
}

# only _sudo_tmp is not checked!
## some GENERATED USING: sudo -h  | sed -nEe '/^  -[^-]+/ { s/.*--([^ =]+).*/_sudo_\1 \\/; s/-/_/; p; }'
vars \
	_sudo_askpass \
	_sudo_background \
	_sudo_bell \
	_sudo_close_from \
	_sudo_chdir \
	_sudo_preserve_env \
	_sudo_edit \
	_sudo_group \
	_sudo_set_home \
	_sudo_help \
	_sudo_host \
	_sudo_login \
	_sudo_remove_timestamp \
	_sudo_reset_timestamp \
	_sudo_list \
	_sudo_non_interactive \
	_sudo_preserve_groups \
	_sudo_prompt \
	_sudo_chroot \
	_sudo_stdin \
	_sudo_shell \
	_sudo_command_timeout \
	_sudo_other_user \
	_sudo_user \
	_sudo_version \
	_sudo_validate \
	\
	\
	_sudo_opts \
	_sudo_arg_key \
	_sudo_arg_val \
	\
	_sudo_nl \
|| exit

_sudo_nl='
' # just a new line
_sudo_user=root

# Why all vairables has _sudo_ as prefix?
# shell vairables are the same as env vairables
# for example if 'user' is used instead of '_sudo_user'
# then the command:   $ user=foo sudo env | grep ^user=
# the 'user' var will be overwritten, or as the current case 
# will throw err "err: 'user' should not be in the enviroment"



while [ "$#" -ne 0 ]; do
	# _sudo_opts=$1 # should not be needed, just in case
	_sudo_arg_key=''
	unset _sudo_tmp
	unset _sudo_arg_val

	# first convent short args to long args:

	case $1 in
		--) shift; break;;
		[!-]*=*) _sudo_env_vars=1; export "$1"; shift; continue;;
		[!-]*) break;; # end of args?

		-[CDghpRTUu]*|-[!-]*[CDghpRTUu]*)
			# get valuae of options that reguire argument

			# from  $1='-buUSER' to  opts=b key=u val=USER
			_sudo_tmp=${1%%[CDghpRTUu]*}
			_sudo_arg_val=${1#"$_sudo_tmp"?}
			_sudo_arg_key=${1%"$_sudo_arg_val"}
			_sudo_arg_key=${_sudo_arg_key#"$_sudo_tmp"}
			# maybe needs optimisation?
			# I will not even try to explain those lines
			# when it brakes just rewrite it
			# ALTERNATIVE CODE: # _sudo_opts=${1%%[CDghpRTUu]*};_sudo_arg_val=${1#"$_sudo_opts"};_sudo_arg_key=${_sudo_arg_val%"${_sudo_arg_val#?}"};_sudo_arg_val=${_sudo_arg_val#"$_sudo_arg_key"}

			[ "$1" = "$_sudo_tmp$_sudo_arg_key$_sudo_arg_val" ] \
			&& case $_sudo_arg_key in *[CDghpRTUu]) true;; *) false; esac \
			|| err "error parsing arguments in -- '${1:-}'" 2


			_sudo_opts=${_sudo_tmp#-}$_sudo_opts
			# _sudo_arg_key=$_sudo_arg_key$_sudo_arg_key
			[ "$_sudo_arg_val" != '' ] || {
				if [ 2 -le $# ]; then
					_sudo_arg_val=$2 && shift
				elif [ "$_sudo_arg_key" = h ] && case ${2:-} in -*) false; esac; then # what will happen when -h - or other case
					_sudo_opts=h$_sudo_opts
					_sudo_arg_key=''
				else
					 err "option requires an argument -- '$1'"
				fi
			}
		;;
		-[!-]*) _sudo_opts=${1#-}$_sudo_opts;;


		###### GENERATED USING: sudo -h | sed -nEe 's/^  (-[^-]+), (--[^ =]+) .+/\2) _sudo_opts=\1;;/p'
		--askpass)          _sudo_opts=A$_sudo_opts;;
		--background)       _sudo_opts=b$_sudo_opts;;
		--bell)             _sudo_opts=B$_sudo_opts;;
		--preserve-env)     _sudo_opts=E$_sudo_opts;;
		--edit)             _sudo_opts=e$_sudo_opts;;
		--set-home)         _sudo_opts=H$_sudo_opts;;
		--help)             _sudo_opts=h$_sudo_opts;;
		--login)            _sudo_opts=i$_sudo_opts;;
		--remove-timestamp) _sudo_opts=K$_sudo_opts;;
		--reset-timestamp)  _sudo_opts=k$_sudo_opts;;
		--list)             _sudo_opts=l$_sudo_opts;;
		--non-interactive)  _sudo_opts=n$_sudo_opts;;
		--preserve-groups)  _sudo_opts=P$_sudo_opts;;
		--stdin)            _sudo_opts=S$_sudo_opts;;
		--shell)            _sudo_opts=s$_sudo_opts;;
		--version)          _sudo_opts=V$_sudo_opts;;
		--validate)         _sudo_opts=v$_sudo_opts;;
		--*) # options with arguments:   => sets _sudo_arg_val
			case ${1#"--"} in
				# todo what option what should do when is empty (--user='')
				preserve-env=*) err "err: unimplemented option -- '${1%%=*}'" ; sudo_arg_val=;; # ony value when '='
				###### GENERATED USING: sudo -h  | sed -nEe 's/^  (-[^-]+), --([^ =]*)=[^ =]+ .+/\2|\2=*) _sudo_arg_key=\1;;/p'
				close-from|close-from=*)           _sudo_arg_key=C;;
				chdir|chdir=*)                     _sudo_arg_key=D;;
				group|group=*)                     _sudo_arg_key=g;;
				host|host=*)                       _sudo_arg_key=h;;
				prompt|prompt=*)                   _sudo_arg_key=p;;
				chroot|chroot=*)                   _sudo_arg_key=R;;
				command-timeout|command-timeout=*) _sudo_arg_key=T;;
				other-user|other-user=*)           _sudo_arg_key=U;;
				user|user=*)                       _sudo_arg_key=u;;

				*) err "unrecognized option '$1'";;
			esac

			# test if _sudo_arg_val is unset vairamle , (not just '' -> null)
			( : "$_sudo_arg_val" ) 2>/dev/null || case $1 in
				*=*) _sudo_arg_val=${1#*=};;
				*)
					[ 2 -le $# ] && _sudo_arg_val=$2 && shift \
					|| err "option '$1' requires an argument'"
				;;
			esac

			[ "$_sudo_arg_val" != '' ] \
			|| case $_sudo_arg_key in [ug]) # options that requires values
				err "Error empty value for $_sudo_arg_key"
			esac
		;;

		*) err "Error parsing '$1', args($#) left: $*" 111;;
	esac

	# todo  complain abut empty optiont
	if [ "$_sudo_arg_key" != '' ]; then
		# case $_sudo_arg_key in [ug]) err  # TODO: error handle
		case $_sudo_arg_key in
			'') ;;
			# @ close-from|close-from=?*)           _sudo_arg_key=C;;
			# -C, --close-from=num   # todo: wut
			# @ chdir|chdir=?*)                     _sudo_arg_key=D;;
			D) _sudo_chdir="$_sudo_arg_val";;
			# by most default sudoers config  -D is not alowed for user? # todo further check if; true

			# @ group|group=?*)                     _sudo_arg_key=g;;
			g) _sudo_group="$_sudo_arg_val"; nonempty "$_sudo_group" group;;
			# @ host|host=?*)                       _sudo_arg_key=h;; # todo: should not be empty (-h '') + more validate
			# @ prompt|prompt=?*)                   _sudo_arg_key=p;;
			# @ chroot|chroot=?*)                   _sudo_arg_key=R;;
			R) _sudo_unimplemented=1;; #_sudo_chroot=$_sudo_arg_val
			#  "you are not permitted to use the -R option with ..." ah sudo rules, todo some day
			# @ command-timeout|command-timeout=?*) _sudo_arg_key=T;;
			# @ other-user|other-user=?*)           _sudo_arg_key=U;;
			# @ user|user=?*)                       _sudo_arg_key=u;;
			u) _sudo_user=$_sudo_arg_val; nonempty "$_sudo_user" name;;
			*) err "err: unimplemented option -- '$_sudo_arg_key'";;
		esac
	fi


	shift
done
_sudo_tmp=''








if [ "$_sudo_opts" != '' ]; then

	case $_sudo_opts in # TODO: TEST ME all:
		*A*S*|*S*A*) err 'the -A and -S options may not be used together';;
		*D*) err 'you are not permitted to use the -D option with';; # todo ?
		*i*E*|*E*i*) err 'you may not specify both the -i and -E options';;
		*i*s*|*s*i*) err 'you may not specify both the -i and -s options';;


		*U*)
			case $_sudo_opts in
				*l*) ;;
				*) err 'the -U option may only be used with the -l option';;
			esac
		;;
	esac


	: grep -v ' #' : <<- TODO
		# the -A and -S options may not be used together
		# Only one of the -e, -h, -i, -K, -l, -s, -v or -V options may be specified
		# the -U option may only be used with the -l option
		the argument to -C must be a number greater than or equal to 3
		# you are not permitted to use the -D option with
		#you may not specify both the -i and -E options

	TODO


	# @ --askpass)          _sudo_opts=A;;
	case $_sudo_opts in *A*)
		[ "${SUDO_ASKPASS:-}" != '' ] || err "no askpass program specified, try setting SUDO_ASKPASS"
		_sudo_askpass=$SUDO_ASKPASS
		 # used $SUDO_ASKPASS from env? never tested? (is this sudo's behavour?)
	esac
	# it assumes that password aways will be needed, exept for root,
	#  password is not neede for Android/MagiskSU, however there is no easy way to detect if pass will be needed

	# @ --background)       _sudo_opts=b;;
	case $_sudo_opts in *b*) _sudo_background='&'; esac

	# @ --bell)             _sudo_opts=B;;
	case $_sudo_opts in *B*) _sudo_bell='\a'; esac # todo : add to begining in prompt

	# @ --preserve-env)     _sudo_opts=E;;
	case $_sudo_opts in *E*) err "err: unimplemented option -- 'E'";esac
	# case $_sudo_opts in *E*) ;; esac # TODO: MUST IMPLEMENT, now is like it is passed -E?

	# @ --edit)             _sudo_opts=e;;
		# sudo will complain 'you may not specify environment variables in edit mode', but this script will allow it
		# also original will create tmp file, hire we execute the EDITOR directly with the _sudo_user on the file
	case $_sudo_opts in *e*) # _sudo_edit=1
		err "err: not done option -- '-e'"
		set -- "${EDITOR:-vi}" "$@" # only outside the loop use 'set --' for -e option
		_sudo_edit=1
	esac


	# @ --set-home)         _sudo_opts=H;;
	case $_sudo_opts in *H*) err "err: unimplemented option -- 'H'";esac # todo combined with -E

	# @ --help)             _sudo_opts=h;;
	case $_sudo_opts in *h*) _sudo_help=0; esac # todo: only help should be specified ? or (sudo -k -h) only???

	# @ --login)            _sudo_opts=i;;
	case $_sudo_opts in *i*) _sudo_login=1; esac

	# @ --remove-timestamp) _sudo_opts=K;;
	case $_sudo_opts in *K*) _sudo_remove_timestamp=1; esac

	# @ --reset-timestamp)  _sudo_opts=k;;
	# Done, nothing to do for this option

	# @ --list)             _sudo_opts=l;;
	case $_sudo_opts in *l*) err "err: unimplemented option -- 'l'"; _sudo_list=1;esac
	# @ --non-interactive)  _sudo_opts=n;;
	case $_sudo_opts in *n*) _sudo_non_interactive=1;esac
	# @ --preserve-groups)
	case $_sudo_opts in *P*) err "err: unimplemented option -- 'p'";esac
	# @ --stdin)            _sudo_opts=S;;
	case $_sudo_opts in *S*) _sudo_stdin=1; esac
	# @ --shell)            _sudo_opts=s;;
	case $_sudo_opts in *s*)
		_sudo_shell=1
	esac
	# @ --version)          _sudo_opts=V;;
	case $_sudo_opts in *V*) err "err: unimplemented option -- 'V'"; _sudo_version=1;esac
	# @ --validate)         _sudo_opts=v;;
	case $_sudo_opts in *v*) err "err: unimplemented option -- 'v'"; _sudo_validate=1;esac

	# note: _sudo_help is error code not jst a 1/'' flag
	case $_sudo_edit${_sudo_help:+1}$_sudo_login$_sudo_shell$_sudo_remove_timestamp$_sudo_list$_sudo_version$_sudo_validate in
		*??*) err 'Only one of the -e, -h, -i, -K, -l, -s, -v or -V options may be specified'
	esac

fi


[ -n "$_sudo_shell" ] && [ -n "$_sudo_login" ] && err 'you may not specify both the -i and -s options'



: "${_sudo_chdir:=$PWD}"

# cd "$_sudo_chdir"  # shoud not  WHEN [ "$_sudo_login$_sudo_shell" != '' ] && [ "$#" -eq 0 ]

# expected "su" to read passwrod from stdin by default,  not tested on all platforms?


if [ "$_sudo_user" != root ]; then
	# id would accept IDs .. but sudo wont
	case $_sudo_user in
		*[!0-9]*) ;;
		*) err "unknown user: $_sudo_user";;
	esac
	_sudo_tmp=$(id -un -- "$_sudo_user" 2>&-)

	[ "$_sudo_tmp" = "$_sudo_user" ] \
	|| err "err: uanexpected ousput from id, expected: _sudo_user='$_sudo_user', got: '$_sudo_tmp'"
fi

# just validate that the user is in the group
if [ "$_sudo_group" != '' ]; then

	_sudo_tmp=$(
		{
			command -v getent >/dev/null \
			&& getent -- group "$_sudo_group" \
			|| cat "${PREFIX:-}"/etc/group
		} | cut -d : -f 1  | tr "$_sudo_nl" :
	)
	#_sudo_tmp="${_sudo_tmp%"${_sudo_tmp##*[!:]}"}" # trim end form multiple ':'

	case :${_sudo_tmp%":"}: in 
		*:"$_sudo_group":*)
			case " $(id -Gn -- "$_sudo_user") " in
				*" $_sudo_group "*) ;;  # all good, user is in the group
				*)
					printf %s \
						"Sorry, user $SUDO_USER" \
						" is not allowed to execute '$1'" \
						" as $_sudo_user:$_sudo_group" \
						" on ${NAME:-$(hostname)}." \
					;	# is $NAME hostname for all distros that use it, todo check?
					echo
					exit 1
				;;
			esac
		;;
		:*[!:]*:) err "unknown group: $_sudo_group";;
		*) err "Error invalid output for group: '$_sudo_tmp' to match '$_sudo_group'";;
	esac
fi

# arguments parsing gone




[ "$_sudo_help" = '' ] || {
	printf %s\\n \
		"sudo - execute a command as another user" \
		"" \
		"usage: sudo -h | -K | -k | -V" \
		"usage: sudo -v [-ABknS] [-g group] [-h host] [-p prompt] [-u user]" \
		"usage: sudo -l [-ABknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]" \
		"usage: sudo [-ABbEHknPS] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user] [VAR=value] [-i|-s] [<command>]" \
		"usage: sudo -e [-ABknS] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user] file ..." \
		"" \
		"Options:" \
		"#   -A, --askpass                 use a helper program for password prompting" \
		"    -b, --background              run command in the background" \
		"    -B, --bell                    ring bell when prompting" \
		"##  -C, --close-from=num          close all file descriptors >= num" \
		"#   -D, --chdir=directory         change the working directory before running command" \
		"#?  -E, --preserve-env            preserve user environment when running command" \
		"?       --preserve-env=list       preserve specific environment variables" \
		"?   -e, --edit                    edit files instead of running a command" \
		"    -g, --group=group             run command as the specified group nam" \
		"#   -H, --set-home                set HOME variable to target user's home dir" \
		"    -h, --help                    display help message and exit" \
		"#   -h, --host=host               run command on host (if supported by plugin)" \
		"?   -i, --login                   run login shell as the target user; a command may also be specified" \
		"    -K, --remove-timestamp        remove timestamp file completely" \
		"?   -k, --reset-timestamp         invalidate timestamp file" \
		"#   -l, --list                    list user's privileges or check a specific command; use twice for longer format" \
		"    -n, --non-interactive         non-interactive mode, no prompts are used" \
		"#   -P, --preserve-groups         preserve group vector instead of setting to target's" \
		"#   -p, --prompt=prompt           use the specified password prompt" \
		"#   -R, --chroot=directory        change the root directory before running command" \
		"    -S, --stdin                   read password from standard input" \
		"?   -s, --shell                   run shell as the target user; a command may also be specified" \
		"#   -T, --command-timeout=timeout terminate command after the specified time limit" \
		"#   -U, --other-user=user         in list mode, display privileges for user" \
		"    -u, --user=user               run command (or edit file) as specified user name" \
		"    -V, --version                 display version information and exit" \
		"#   -v, --validate                update user's timestamp without running a command" \
		"    --                            stop processing command line arguments" \
	;
	exit "$_sudo_help"
}






if [ "$SUDO_UID" -eq 0 ] && [ "$_sudo_user" = "$SUDO_USER" ]; then
	# todo: checking for  _sudo_login/_sudo_shell
	eval 'exec "$@" '" $_sudo_background"
elif
	{
		# [ "$_sudo_askpass" != '' ] ||
		[ "$_sudo_stdin" != '' ] || { [ -r /dev/tty ] && [ -w /dev/tty ]; } || {
			err 'a terminal is required to read the password; either use the -S option to read from standard input (--or configure an askpass helper--)' 0 # askpass not done
			err 'a password is required' 1
		}

		# expected password to be needed. ring the bell:
		# is tty used in real sudo for the bell
		[ "$_sudo_bell" = '' ] || printf %b "${_sudo_bell:+BELL\\n}" >/dev/tty # todo when no tty //OR waht should happen when '-S' is passed
		# "BELL\n" IS ONLY FOR TEST:

	};
	#elif #continues:
	[ "$_sudo_non_interactive" = 1 ];
then
	err 'a password is required'
elif [ "$_sudo_stdin" = 1 ]; then
	if [ -n "$_sudo_login$_sudo_shell" ]; then
		exec su ${_sudo_login:+"$_sudo_login"} -- "$_sudo_user"
	else
		exec su \
			-c 'cd "$0" && exec     "$@"'" $_sudo_background" \
			-- "$_sudo_user" "$_sudo_chdir" "$@" \
		;
	fi
else
	if [ -n "$_sudo_login" ]; then
		# todo:$_sudo_background ?
		exec su ${_sudo_login:+"$_sudo_login"} \
			-c 'cd "$0" && exec <&3 "${SHELL:-/bin/sh}"' \
			-- "$_sudo_user" "$_sudo_chdir" 3<&0 </dev/tty \
		;
	elif [ -n "$_sudo_shell" ]; then
		# TODO not done
		exec su ${_sudo_login:+"$_sudo_login"} \
			-c 'cd "$0" && exec 0<&9 1>&9 "${SHELL:-/bin/sh}" # ' \
			-- "$_sudo_user" "$_sudo_chdir" 9<&0 0</dev/tty 9>&1 1>/dev/tty \
		;
	else
		# exec su \
			# -c 'cd "$0" && exec 0<&9 2>&9 "$@"'" $_sudo_background" \
			# -- "$_sudo_user" "$_sudo_chdir" "$@" 9<&0 0</dev/tty 9>&2 2>/dev/tty \
		# ;
# TODO $_sudo_chdir
# TODO $_sudo_askpass
		# use su-cmd-shell in case of error message
		# exec su -c '"$@"'" $_sudo_background" -- "$_sudo_user" "su-cmd-shell" "$@"
		exec su \
			-c 'exec "$@"  0<&9 1>&8 2>&7  9>&- 8>&- 7>&-'"  ${_sudo_background:-;} exit # " \
			-- "$_sudo_user" "su-cmd-shell" "$@"  9<&0 8>&1 7>&2  0</dev/tty 1>/dev/tty 2>/dev/tty \
		;
	fi
	# exec su \
		# -c '
			# if [ "$SHELL" = "$0" ];
			# then cd "$1";shift;else cd "$0" &&
			# fi ; exec <&3 "$@"
		# ' "$_sudo_user" \
		# -- "$_sudo_chdir" "$@" 3<&0 </dev/tty \
	# ;
fi

# prints su's output "Password: " to tty in case /dev/stderr is redirected (micro editor using sucmd)
