#!/bin/sh
set -feu

export SUDO_COMMAND=$@ SUDO_USER=${USER:-$(id -un)} SUDO_UID=${EUID:-$(id -u)} SUDO_GID=${GROUPS:-$(id -g)}

err() {
	printf '%s\n' "${0##*/}: $1" >&2
	exit "${2:-1}" 
}

# safe check if var is NOT exported
vars() {
	for i; do
		eval "if ( : \"\${${i}:?}\"; ); then return \$? ; else ${i}=''; fi "
	done 1>/dev/null 2>/dev/null
}
vars \
	_sudo_askpass \
	\
	_sudo_user \
	_sudo_stdin \
	\
	_sudo_login \
	_sudo_shell \
	_sudo_background \
	_sudo_bell \
	_sudo_chdir \
	_sudo_to_exit \
	_sudo_to_usage \
	\
	_sudo_opts \
	_sudo_opts_ \
	_sudo_arg_key \
	_sudo_arg_val \
	\
	_sudo_env_vars \
	|| exit


_sudo_user=root
_sudo_stdin=0


while [ "$#" -ne 0 ]; do
#  would it be better to iterate using $(substr "$1" "$i" 1) through short args args
	# _sudo_opts=$1 # should not be needed, just in case
	unset _sudo_opts_
	unset _sudo_arg_key
	unset _sudo_arg_val

	# first convent short args to long args:

	case $1 in
		--) shift; break;;
		-[CDghpRTUu]*|-[!-]*[CDghpRTUu]*)
		# if is not long arg, get only current short arg and sepanate its vanue
			# get valuae of options that reguire argument

			_sudo_opts_=${1%%[CDghpRTUu]*}
			_sudo_arg_val=${1#"$_sudo_opts_"?}
			_sudo_arg_key=${1%"$_sudo_arg_val"} # tmp
			_sudo_arg_key=${_sudo_arg_key#"$_sudo_opts_"}
			# maybe needs optimisation?
			# I will not even try to explain those lines
			# when it brakes just rewrite it
			# ALTERNATIVE CODE: # _sudo_opts=${1%%[CDghpRTUu]*};_sudo_arg_val=${1#"$_sudo_opts"};_sudo_arg_key=${_sudo_arg_val%"${_sudo_arg_val#?}"};_sudo_arg_val=${_sudo_arg_val#"$_sudo_arg_key"}

			[ "$1" = "$_sudo_opts_$_sudo_arg_key$_sudo_arg_val" ] \
			&& case $_sudo_arg_key in *[CDghpRTUu]) true;; *) false; esac \
			|| err "error parsing arguments in -- '${1:-}'" 2


			_sudo_opts=$_sudo_opts${_sudo_opts#-}
			# _sudo_arg_key=$_sudo_arg_key$_sudo_arg_key
			[ "$_sudo_arg_val" != '' ] || {
				if [ 2 -le $# ]; then
					_sudo_arg_val=$2 && shift
				else
					[ "$_sudo_arg_key" = -h ] && _sudo_opts=h$_sudo_opts
				fi || err "option requires an argument -- '$1'"
			}
		;;
		-[!-]*) _sudo_opts=${1#-}$_sudo_opts;;

		[!-]*=*) _sudo_env_vars=@; export "$1"; continue;;

		[!-]*) break;; # end of args?

		###### GENERATED USING: sudo -h | sed -nEe 's/^  (-[^-]+), (--[^ =]+) .+/\2) _sudo_opts=\1;;/p'
		--askpass)          _sudo_opts=A$_sudo_opts;;
		--background)       _sudo_opts=b$_sudo_opts;;
		--bell)             _sudo_opts=B$_sudo_opts;;
		--preserve-env)     _sudo_opts=E$_sudo_opts;;
		--edit)             _sudo_opts=e$_sudo_opts;;
		--set-home)         _sudo_opts=H$_sudo_opts;;
		--help)             _sudo_opts=h$_sudo_opts;;
		--login)            _sudo_opts=i$_sudo_opts;;
		--remove-timestamp) _sudo_opts=K$_sudo_opts;;
		--reset-timestamp)  _sudo_opts=k$_sudo_opts;;
		--list)             _sudo_opts=l$_sudo_opts;;
		--non-interactive)  _sudo_opts=n$_sudo_opts;;
		--preserve-groups)  _sudo_opts=P$_sudo_opts;;
		--stdin)            _sudo_opts=S$_sudo_opts;;
		--shell)            _sudo_opts=s$_sudo_opts;;
		--version)          _sudo_opts=V$_sudo_opts;;
		--validate)         _sudo_opts=v$_sudo_opts;;
		--*) # need to parse options with arg separately
			case ${1#--} in
				preserve-env|preserve-env=?*) err "err, unimplemented option -- '${1%%=*}'";; # we do not have a short option for this one
				###### GENERATED USING: sudo -h  | sed -nEe 's/^  (-[^-]+), --([^ =]*)=[^ =]+ .+/\2|\2=?*) _sudo_arg_key=\1;;/p'
				close-from|close-from=?*)           _sudo_arg_key=C;;
				chdir|chdir=?*)                     _sudo_arg_key=D;;
				group|group=?*)                     _sudo_arg_key=g;;
				host|host=?*)                       _sudo_arg_key=h;;
				prompt|prompt=?*)                   _sudo_arg_key=p;;
				chroot|chroot=?*)                   _sudo_arg_key=R;;
				command-timeout|command-timeout=?*) _sudo_arg_key=T;;
				other-user|other-user=?*)           _sudo_arg_key=U;;
				user|user=?*)                       _sudo_arg_key=u;;

				*) err "unrecognized option '$1'";;
			esac
			case $1 in
				*=*) _sudo_arg_val=${1#*=};;
				*)
					[ 2 -le $# ] && _sudo_arg_val=$2 && shift \
					|| err "option '$1' requires an argument'"
				;;
			esac
		;;

		*) err "Error parsing '$1', args($#) left: $*" 111;;
	esac
	
(set -x +ue # easy way to deug
	__1=$1
	_sudo_opts=$_sudo_opts
	_sudo_opts_=$_sudo_opts_
	_sudo_arg_val=$_sudo_arg_val
	_sudo_arg_key=$_sudo_arg_key
)||:



	case ${_sudo_arg_key:-} in
		'') ;;
		# @ close-from|close-from=?*)           _sudo_arg_key=C;;
		# -C, --close-from=num   # todo: wut
		# @ chdir|chdir=?*)                     _sudo_arg_key=D;;
		D) _sudo_chdir="$_sudo_arg_val";;
		# 9/10 - by most default sudoers config  -D is not alowed for user? # todo further check if; true 
		# @ group|group=?*)                     _sudo_arg_key=g;;
		# @ host|host=?*)                       _sudo_arg_key=h;;
		# h) _sudo_to_usage=long-message
		# @ prompt|prompt=?*)                   _sudo_arg_key=p;;
		# @ chroot|chroot=?*)                   _sudo_arg_key=R;;
		R) _sudo_unimplemented=1;; #_sudo_chroot=$_sudo_arg_val
		#  "you are not permitted to use the -R option with ..." ah sudo rules, todo some day
		# @ command-timeout|command-timeout=?*) _sudo_arg_key=T;;
		# @ other-user|other-user=?*)           _sudo_arg_key=U;;
		# @ user|user=?*)                       _sudo_arg_key=u;;
		u) _sudo_user=$_sudo_arg_val;; # PLS work from the first time, pretty pls
		*) err "err, unimplemented option -- '$_sudo_arg_key'";;
	esac


	shift
	# arg "$@" # debug log todo: rm me
done









if [ "$_sudo_opts" != '' ]; then

	# @ --askpass)          _sudo_opts=A;;
	case ${_sudo_opts:?} in *A*)
		[ "${SUDO_ASKPASS:-}" != '' ] || err "no askpass program specified, try setting SUDO_ASKPASS"
		_sudo_askpass=$SUDO_ASKPASS
	esac  # used $SUDO_ASKPASS from env? never tested? (is this sudo's behavour?)
	# it assumes that password aways will be needed, exept for root,
	#  password is not neede for Android/MagiskSU, however there is no easy way to detect if pass will be needed

	# @ --background)       _sudo_opts=b;;
	case $_sudo_opts in *b*) _sudo_background='&'; esac

	# @ --bell)             _sudo_opts=B;;
	case $_sudo_opts in *B*) _sudo_bell='\a'; esac # todo : add to begining in prompt

	# @ --preserve-env)     _sudo_opts=E;;
	case $_sudo_opts in *E*) err "err, unimplemented option -- 'E'";esac
	# case $_sudo_opts in *E*) ;; esac # TODO: MUST IMPLEMENT, now is like it is passed -E

	# @ --edit)             _sudo_opts=e;;
		# sudo will complain 'you may not specify environment variables in edit mode', but this script will not
		# also will create tmp file, hire we execute the EDITOR directly with the user on the file
	case $_sudo_opts in *e*)
		set -- "${EDITOR:-vi}" "$@" # only outside the loop use 'set --' for -e option
	esac
	

	# @ --set-home)         _sudo_opts=H;;
	case $_sudo_opts in *H*) err "err, unimplemented option -- 'H'";esac

	# @ --help)             _sudo_opts=h;;
	case $_sudo_opts in *h*) err "err, unimplemented option -- 'h'";esac # todo: next

	# @ --login)            _sudo_opts=i;;
	case $_sudo_opts in *i*) _sudo_login=1; esac

	# @ --remove-timestamp) _sudo_opts=K;;
	case $_sudo_opts in *K*) _sudo_remove_timestamp=1; esac

	# @ --reset-timestamp)  _sudo_opts=k;;
	#SKIPED

	# @ --list)             _sudo_opts=l;;
	case $_sudo_opts in *l*) err "err, unimplemented option -- 'l'";esac
	# @ --non-interactive)  _sudo_opts=n;;
	case $_sudo_opts in *i*) err "err, unimplemented option -- 'i'";esac
	# @ --preserve-groups)  _sudo_opts=P;;
	case $_sudo_opts in *P*) err "err, unimplemented option -- 'p'";esac
	# @ --stdin)            _sudo_opts=S;;
	case $_sudo_opts in *S*) _sudo_stdin=1; esac
	# @ --shell)            _sudo_opts=s;;
	case $_sudo_opts in *s*)
		[ "$_sudo_login" = 1 ]] && err 'you may not specify both the -i and -s options'
		_sudo_shell=1
	esac
	# @ --version)          _sudo_opts=V;;
	case $_sudo_opts in *i*) err "err, unimplemented option -- 'i'";esac
	# @ --validate)         _sudo_opts=v;;
	case $_sudo_opts in *v*) err "err, unimplemented option -- 'v'";esac
fi






# TODO CONTINUE HIRE ${dstndstndstndstndstn?}
# exit 123

# case $_sudo_to_usage in
#	help) TODO help message;;
#	usage) TODO 2-5 lies usage;;
# esac

[ -n "$_sudo_to_exit" ] && exit "$_sudo_to_exit"

[ -n "$_sudo_shell" ] && [ -n "$_sudo_login" ] && {
	echo >&2 'sudo: you may not specify both the -i and -s options'
	# TODO usage help message
	exit 1
}

[ "$#" -eq 0 ] && [ "$_sudo_login$_sudo_shell" = '' ] && {
	echo TODO usage help message
	exit 1
}

printf "$_sudo_bell" >/dev/tty
# [ -t 2 ] || printf 'Password: ' >/dev/tty # todo: better way

: ${_sudo_chdir:=${PWD:-$(pwd)}}
: ${_sudo_user:=root}
# print 'Password: ' to tty in case /dev/stderr is redirected

	# cd "$_sudo_chdir"  # shoud not  WHEN [ -n "$_sudo_login$_sudo_shell" ] && [ "$#" -eq 0 ]

	# expected "su" to read passwrod from stdin by default,  not tested on all platforms
	# bug: 'Password:' prompt will be outputed to STDERR not /dev/tty, micro will not prompt
	# bug: I/O /dev/tty in invoked command will fail ""

	# ${_sudo_login:+"$_sudo_login"} -> dont risk IFS to include '-l'
if [ "$SUDO_UID" -eq 0 ] && [ "$_sudo_user" = root ]; then
	eval 'exec "$@"'" $_sudo_background"
	# todo: checking for  _sudo_login/_sudo_shell

elif [ "$_sudo_stdin" -eq 1 ]; then
	if [ -n "$_sudo_login$_sudo_shell" ]; then
		exec su ${_sudo_login:+"$_sudo_login"} -- "$_sudo_user"
	else
		exec su -c 'cd "$0" && exec     "$@"'" $_sudo_background" -- "$_sudo_user" "$_sudo_chdir" "$@"
	fi
else
	if [ -n "$_sudo_login" ]; then
		err \!" _sudo_login withot stdin" 3
		# todo:$_sudo_background ?
		# exec su ${_sudo_login:+"$_sudo_login"} -c 'cd "$0" && exec <&3 "${SHELL:-/bin/sh}"' -- "$_sudo_user" "$_sudo_chdir" 3<&0 </dev/tty
	elif [ -n "$_sudo_shell" ]; then
		# TODO not done
		exec su ${_sudo_login:+"$_sudo_login"} -c 'cd "$0" && exec 0<&9 1>&9 "${SHELL:-/bin/sh}"' -- "$_sudo_user" "$_sudo_chdir" 9<&0 0</dev/tty 9>&1 1>/dev/tty
	else
		# exec su -c 'cd "$0" && exec 0<&9 2>&9 "$@"'" $_sudo_background" -- "$_sudo_user" "$_sudo_chdir" "$@" 9<&0 0</dev/tty 9>&2 2>/dev/tty
# TODO $_sudo_chdir
# TODO $_sudo_askpass
		# use su-cmd-shell in case of error message
		# exec su -c '"$@"'" $_sudo_background" -- "$_sudo_user" "su-cmd-shell" "$@"
		exec su -c 'exec "$@"  0<&9 1>&8 2>&7  9>&- 8>&- 7>&-'"  $_sudo_background ; exit # " -- "$_sudo_user" "su-cmd-shell" "$@"  9<&0 8>&1 7>&2  0</dev/tty 1>/dev/tty 2>/dev/tty 
	fi
	# exec su -c 'if [ "$SHELL" = "$0" ]; then cd "$1";shift;else cd "$0" && fi ; exec <&3 "$@"' "$_sudo_user" -- "$_sudo_chdir" "$@" 3<&0 </dev/tty
fi
